.TH "DOCKER" "1" "May 07, 2013" "0.1" "Docker"
.SH NAME
docker \- Docker Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.\" Man page generated from reStructeredText.
.
.sp
This documentation has the following resources:
.SH CONCEPTS
.sp
Contents:
.SS Standard Containers
.SS What is a Standard Container?
.sp
Docker defines a unit of software delivery called a Standard Container. The goal of a Standard Container is to encapsulate a software component and all its dependencies in
a format that is self\-describing and portable, so that any compliant runtime can run it without extra dependency, regardless of the underlying machine and the contents of the container.
.sp
The spec for Standard Containers is currently work in progress, but it is very straightforward. It mostly defines 1) an image format, 2) a set of standard operations, and 3) an execution environment.
.sp
A great analogy for this is the shipping container. Just like Standard Containers are a fundamental unit of software delivery, shipping containers (\fI\%http://bricks.argz.com/ins/7823-1/12\fP) are a fundamental unit of physical delivery.
.SS Standard operations
.sp
Just like shipping containers, Standard Containers define a set of STANDARD OPERATIONS. Shipping containers can be lifted, stacked, locked, loaded, unloaded and labelled. Similarly, standard containers can be started, stopped, copied, snapshotted, downloaded, uploaded and tagged.
.SS Content\-agnostic
.sp
Just like shipping containers, Standard Containers are CONTENT\-AGNOSTIC: all standard operations have the same effect regardless of the contents. A shipping container will be stacked in exactly the same way whether it contains Vietnamese powder coffee or spare Maserati parts. Similarly, Standard Containers are started or uploaded in the same way whether they contain a postgres database, a php application with its dependencies and application server, or Java build artifacts.
.SS Infrastructure\-agnostic
.sp
Both types of containers are INFRASTRUCTURE\-AGNOSTIC: they can be transported to thousands of facilities around the world, and manipulated by a wide variety of equipment. A shipping container can be packed in a factory in Ukraine, transported by truck to the nearest routing center, stacked onto a train, loaded into a German boat by an Australian\-built crane, stored in a warehouse at a US facility, etc. Similarly, a standard container can be bundled on my laptop, uploaded to S3, downloaded, run and snapshotted by a build server at Equinix in Virginia, uploaded to 10 staging servers in a home\-made Openstack cluster, then sent to 30 production instances across 3 EC2 regions.
.SS Designed for automation
.sp
Because they offer the same standard operations regardless of content and infrastructure, Standard Containers, just like their physical counterpart, are extremely well\-suited for automation. In fact, you could say automation is their secret weapon.
.sp
Many things that once required time\-consuming and error\-prone human effort can now be programmed. Before shipping containers, a bag of powder coffee was hauled, dragged, dropped, rolled and stacked by 10 different people in 10 different locations by the time it reached its destination. 1 out of 50 disappeared. 1 out of 20 was damaged. The process was slow, inefficient and cost a fortune \- and was entirely different depending on the facility and the type of goods.
.sp
Similarly, before Standard Containers, by the time a software component ran in production, it had been individually built, configured, bundled, documented, patched, vendored, templated, tweaked and instrumented by 10 different people on 10 different computers. Builds failed, libraries conflicted, mirrors crashed, post\-it notes were lost, logs were misplaced, cluster updates were half\-broken. The process was slow, inefficient and cost a fortune \- and was entirely different depending on the language and infrastructure provider.
.SS Industrial\-grade delivery
.sp
There are 17 million shipping containers in existence, packed with every physical good imaginable. Every single one of them can be loaded on the same boats, by the same cranes, in the same facilities, and sent anywhere in the World with incredible efficiency. It is embarrassing to think that a 30 ton shipment of coffee can safely travel half\-way across the World in \fIless time\fP than it takes a software team to deliver its code from one datacenter to another sitting 10 miles away.
.sp
With Standard Containers we can put an end to that embarrassment, by making INDUSTRIAL\-GRADE DELIVERY of software a reality.
.SS Standard Container Specification
.sp
(TODO)
.SS Image format
.SS Standard operations
.INDENT 0.0
.IP \(bu 2
Copy
.IP \(bu 2
Run
.IP \(bu 2
Stop
.IP \(bu 2
Wait
.IP \(bu 2
Commit
.IP \(bu 2
Attach standard streams
.IP \(bu 2
List filesystem changes
.IP \(bu 2
.UNINDENT
.SS Execution environment
.SS Root filesystem
.SS Environment variables
.SS Process arguments
.SS Networking
.SS Process namespacing
.SS Resource limits
.SS Process monitoring
.SS Logging
.SS Signals
.SS Pseudo\-terminal allocation
.SS Security
.SH INSTALLATION
.sp
Contents:
.SS Ubuntu Linux
.INDENT 0.0
.INDENT 3.5
\fBPlease note this project is currently under heavy development. It should not be used in production.\fP
.UNINDENT
.UNINDENT
.sp
Installing on Ubuntu 12.04 and 12.10
.sp
Right now, the officially supported distributions are:
.sp
Ubuntu 12.04 (precise LTS)
Ubuntu 12.10 (quantal)
Docker probably works on other distributions featuring a recent kernel, the AUFS patch, and up\-to\-date lxc. However this has not been tested.
.SS Install dependencies:
.sp
.nf
.ft C
sudo apt\-get install lxc wget bsdtar curl
sudo apt\-get install linux\-image\-extra\-\(gauname \-r\(ga
.ft P
.fi
.sp
The linux\-image\-extra package is needed on standard Ubuntu EC2 AMIs in order to install the aufs kernel module.
.sp
Install the latest docker binary:
.sp
.nf
.ft C
wget http://get.docker.io/builds/$(uname \-s)/$(uname \-m)/docker\-master.tgz
tar \-xf docker\-master.tgz
.ft P
.fi
.sp
Run your first container!
.sp
.nf
.ft C
cd docker\-master
.ft P
.fi
.sp
.nf
.ft C
sudo ./docker run \-i \-t ubuntu /bin/bash
.ft P
.fi
.sp
Consider adding docker to your PATH for simplicity.
.sp
Continue with the \fIhello_world\fP example.
.SS Mac OS X and other linux
.INDENT 0.0
.INDENT 3.5
Please note this is a community contributed installation path. The only \(aqofficial\(aq installation is using the \fIubuntu_linux\fP installation path. This version
may be out of date because it depends on some binaries to be updated and published
.UNINDENT
.UNINDENT
.SS Requirements
.sp
We currently rely on some Ubuntu\-linux specific packages, this will change in the future, but for now we provide a
streamlined path to install Virtualbox with a Ubuntu 12.10 image using Vagrant.
.INDENT 0.0
.IP 1. 3
Install virtualbox from \fI\%https://www.virtualbox.org/\fP (or use your package manager)
.IP 2. 3
Install vagrant from \fI\%http://www.vagrantup.com/\fP (or use your package manager)
.IP 3. 3
Install git if you had not installed it before, check if it is installed by running
\fBgit\fP in a terminal window
.UNINDENT
.sp
We recommend having at least about 2Gb of free disk space and 2Gb RAM (or more).
.SS Installation
.INDENT 0.0
.IP 1. 3
Fetch the docker sources
.UNINDENT
.sp
.nf
.ft C
git clone https://github.com/dotcloud/docker.git
.ft P
.fi
.INDENT 0.0
.IP 2. 3
Run vagrant from the sources directory
.UNINDENT
.sp
.nf
.ft C
vagrant up
.ft P
.fi
.sp
Vagrant will:
.INDENT 0.0
.IP \(bu 2
Download the Quantal64 base ubuntu virtual machine image from get.docker.io/
.IP \(bu 2
Boot this image in virtualbox
.UNINDENT
.sp
Then it will use Puppet to perform an initial setup in this machine:
.INDENT 0.0
.IP \(bu 2
Download & untar the most recent docker binary tarball to vagrant homedir.
.IP \(bu 2
Debootstrap to /var/lib/docker/images/ubuntu.
.IP \(bu 2
Install & run dockerd as service.
.IP \(bu 2
Put docker in /usr/local/bin.
.IP \(bu 2
Put latest Go toolchain in /usr/local/go.
.UNINDENT
.sp
You now have a Ubuntu Virtual Machine running with docker pre\-installed.
.sp
To access the VM and use Docker, Run \fBvagrant ssh\fP from the same directory as where you ran
\fBvagrant up\fP. Vagrant will make sure to connect you to the correct VM.
.sp
.nf
.ft C
vagrant ssh
.ft P
.fi
.sp
Now you are in the VM, run docker
.sp
.nf
.ft C
docker
.ft P
.fi
.sp
Continue with the \fIhello_world\fP example.
.SS Windows
.INDENT 0.0
.INDENT 3.5
Please note this is a community contributed installation path. The only \(aqofficial\(aq installation is using the \fIubuntu_linux\fP installation path. This version
may be out of date because it depends on some binaries to be updated and published
.UNINDENT
.UNINDENT
.SS Requirements
.INDENT 0.0
.IP 1. 3
Install virtualbox from \fI\%https://www.virtualbox.org\fP \- or follow this \fI\%tutorial\fP
.UNINDENT
.INDENT 0.0
.IP 2. 3
Install vagrant from \fI\%http://www.vagrantup.com\fP \- or follow this \fI\%tutorial\fP
.UNINDENT
.INDENT 0.0
.IP 3. 3
Install git with ssh from \fI\%http://git-scm.com/downloads\fP \- or follow this \fI\%tutorial\fP
.UNINDENT
.sp
We recommend having at least 2Gb of free disk space and 2Gb of RAM (or more).
.SS Opening a command prompt
.sp
First open a cmd prompt. Press Windows key and then press “R” key. This will open the RUN dialog box for you. Type “cmd” and press Enter. Or you can click on Start, type “cmd” in the “Search programs and files” field, and click on cmd.exe.
[image: Git install]
[image]
.sp
This should open a cmd prompt window.
[image: run docker]
[image]
.sp
Alternatively, you can also use a Cygwin terminal, or Git Bash (or any other command line program you are usually using). The next steps would be the same.
.SS Launch an Ubuntu virtual server
.sp
Let’s download and run an Ubuntu image with docker binaries already installed.
.sp
.nf
.ft C
git clone https://github.com/dotcloud/docker.git
cd docker
vagrant up
.ft P
.fi
[image: run docker]
[image]
.sp
Congratulations! You are running an Ubuntu server with docker installed on it. You do not see it though, because it is running in the background.
.SS Log onto your Ubuntu server
.sp
Let’s log into your Ubuntu server now. To do so you have two choices:
.INDENT 0.0
.IP \(bu 2
Use Vagrant on Windows command prompt OR
.IP \(bu 2
Use SSH
.UNINDENT
.SS Using Vagrant on Windows Command Prompt
.sp
Run the following command
.sp
.nf
.ft C
vagrant ssh
.ft P
.fi
.sp
You may see an error message starting with “\fIssh\fP executable not found”. In this case it means that you do not have SSH in your PATH. If you do not have SSH in your PATH you can set it up with the “set” command. For instance, if your ssh.exe is in the folder named “C:Program Files (x86)Gitbin”, then you can run the following command:
.sp
.nf
.ft C
set PATH=%PATH%;C:\eProgram Files (x86)\eGit\ebin
.ft P
.fi
[image: run docker]
[image]
.SS Using SSH
.sp
First step is to get the IP and port of your Ubuntu server. Simply run:
.sp
.nf
.ft C
vagrant ssh\-config
.ft P
.fi
.sp
You should see an output with HostName and Port information. In this example, HostName is 127.0.0.1 and port is 2222. And the User is “vagrant”. The password is not shown, but it is also “vagrant”.
[image: run docker]
[image]
.sp
You can now use this information for connecting via SSH to your server. To do so you can:
.INDENT 0.0
.IP \(bu 2
Use putty.exe OR
.IP \(bu 2
Use SSH from a terminal
.UNINDENT
.SS Use putty.exe
.sp
You can download putty.exe from this page \fI\%http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html\fP
Launch putty.exe and simply enter the information you got from last step.
[image: run docker]
[image]
.sp
Open, and enter user = vagrant and password = vagrant.
[image: run docker]
[image]
.SS SSH from a terminal
.sp
You can also run this command on your favorite terminal (windows prompt, cygwin, git\-bash, …). Make sure to adapt the IP and port from what you got from the vagrant ssh\-config command.
.sp
.nf
.ft C
ssh vagrant@127.0.0.1 –p 2222
.ft P
.fi
.sp
Enter user = vagrant and password = vagrant.
[image: run docker]
[image]
.sp
Congratulations, you are now logged onto your Ubuntu Server, running on top of your Windows machine !
.SS Running Docker
.sp
First you have to be root in order to run docker. Simply run the following command:
.sp
.nf
.ft C
sudo su
.ft P
.fi
.sp
You are now ready for the docker’s “hello world” example. Run
.sp
.nf
.ft C
docker run \-a busybox echo hello world
.ft P
.fi
[image: run docker]
[image]
.sp
All done!
.sp
Now you can continue with the \fIhello_world\fP example.
.SS Amazon EC2
.INDENT 0.0
.INDENT 3.5
Please note this is a community contributed installation path. The only \(aqofficial\(aq installation is using the \fIubuntu_linux\fP installation path. This version
may be out of date because it depends on some binaries to be updated and published
.UNINDENT
.UNINDENT
.SS Installation
.sp
Docker can now be installed on Amazon EC2 with a single vagrant command. Vagrant 1.1 or higher is required.
.INDENT 0.0
.IP 1. 3
Install vagrant from \fI\%http://www.vagrantup.com/\fP (or use your package manager)
.IP 2. 3
Install the vagrant aws plugin
.sp
.nf
.ft C
vagrant plugin install vagrant\-aws
.ft P
.fi
.IP 3. 3
Get the docker sources, this will give you the latest Vagrantfile and puppet manifests.
.sp
.nf
.ft C
git clone https://github.com/dotcloud/docker.git
.ft P
.fi
.IP 4. 3
Check your AWS environment.
.sp
Create a keypair specifically for EC2, give it a name and save it to your disk. \fII usually store these in my ~/.ssh/ folder\fP.
.sp
Check that your default security group has an inbound rule to accept SSH (port 22) connections.
.IP 5. 3
Inform Vagrant of your settings
.sp
Vagrant will read your access credentials from your environment, so we need to set them there first. Make sure
you have everything on amazon aws setup so you can (manually) deploy a new image to EC2.
.sp
.nf
.ft C
export AWS_ACCESS_KEY_ID=xxx
export AWS_SECRET_ACCESS_KEY=xxx
export AWS_KEYPAIR_NAME=xxx
export AWS_SSH_PRIVKEY=xxx
.ft P
.fi
.sp
The environment variables are:
.INDENT 3.0
.IP \(bu 2
\fBAWS_ACCESS_KEY_ID\fP \- The API key used to make requests to AWS
.IP \(bu 2
\fBAWS_SECRET_ACCESS_KEY\fP \- The secret key to make AWS API requests
.IP \(bu 2
\fBAWS_KEYPAIR_NAME\fP \- The name of the keypair used for this EC2 instance
.IP \(bu 2
\fBAWS_SSH_PRIVKEY\fP \- The path to the private key for the named keypair, for example \fB~/.ssh/docker.pem\fP
.UNINDENT
.sp
You can check if they are set correctly by doing something like
.sp
.nf
.ft C
echo $AWS_ACCESS_KEY_ID
.ft P
.fi
.IP 6. 3
Do the magic!
.sp
.nf
.ft C
vagrant up \-\-provider=aws
.ft P
.fi
.sp
If it stalls indefinitely on \fB[default] Waiting for SSH to become available...\fP, Double check your default security
zone on AWS includes rights to SSH (port 22) to your container.
.sp
If you have an advanced AWS setup, you might want to have a look at the \fI\%https://github.com/mitchellh/vagrant-aws\fP
.IP 7. 3
Connect to your machine
.sp
.nf
.ft C
vagrant ssh
.ft P
.fi
.IP 8. 3
Your first command
.sp
Now you are in the VM, run docker
.sp
.nf
.ft C
docker
.ft P
.fi
.UNINDENT
.sp
Continue with the \fIhello_world\fP example.
.SH EXAMPLES
.sp
Contents:
.SS Hello World
.sp
This is the most basic example available for using docker
.sp
This example assumes you have Docker installed.
.sp
Download the ubuntu container
.sp
.nf
.ft C
# Download an ubuntu image
docker pull ubuntu
.ft P
.fi
.sp
Alternatively you can select \fIbusybox\fP, a bare minimal linux system. The
images are retrieved from the docker repository.
.sp
.nf
.ft C
#run a simple echo command, that will echo hello world back to the console over standard out.
docker run ubuntu /bin/echo hello world
.ft P
.fi
.sp
\fBExplanation:\fP
.INDENT 0.0
.IP \(bu 2
\fB"docker run"\fP run a command in a new container
.IP \(bu 2
\fB"ubuntu"\fP is the image we want to run the command inside of.
.IP \(bu 2
\fB"/bin/echo"\fP is the command we want to run in the container
.IP \(bu 2
\fB"hello world"\fP is the input for the echo command
.UNINDENT
.sp
\fBVideo:\fP
.sp
See the example in action
.sp
Continue to the \fIhello_world_daemon\fP example.
.SS Hello World Daemon
.sp
The most boring daemon ever written.
.sp
This example assumes you have Docker installed and with the ubuntu image already imported \fBdocker pull ubuntu\fP.
We will use the ubuntu image to run a simple hello world daemon that will just print hello world to standard
out every second. It will continue to do this until we stop it.
.sp
\fBSteps:\fP
.sp
.nf
.ft C
$ CONTAINER_ID=$(docker run \-d ubuntu /bin/sh \-c "while true; do echo hello world; sleep 1; done")
.ft P
.fi
.sp
We are going to run a simple hello world daemon in a new container made from the busybox daemon.
.INDENT 0.0
.IP \(bu 2
\fB"docker run \-d "\fP run a command in a new container. We pass "\-d" so it runs as a daemon.
.IP \(bu 2
\fB"ubuntu"\fP is the image we want to run the command inside of.
.IP \(bu 2
\fB"/bin/sh \-c"\fP is the command we want to run in the container
.IP \(bu 2
\fB"while true; do echo hello world; sleep 1; done"\fP is the mini script we want to run, that will just print hello world once a second until we stop it.
.IP \(bu 2
\fB$CONTAINER_ID\fP the output of the run command will return a container id, we can use in future commands to see what is going on with this process.
.UNINDENT
.sp
.nf
.ft C
$ docker logs $CONTAINER_ID
.ft P
.fi
.sp
Check the logs make sure it is working correctly.
.INDENT 0.0
.IP \(bu 2
\fB"docker logs\fP" This will return the logs for a container
.IP \(bu 2
\fB$CONTAINER_ID\fP The Id of the container we want the logs for.
.UNINDENT
.sp
.nf
.ft C
docker attach $CONTAINER_ID
.ft P
.fi
.sp
Attach to the container to see the results in realtime.
.INDENT 0.0
.IP \(bu 2
\fB"docker attach\fP" This will allow us to attach to a background process to see what is going on.
.IP \(bu 2
\fB$CONTAINER_ID\fP The Id of the container we want to attach too.
.UNINDENT
.sp
.nf
.ft C
docker ps
.ft P
.fi
.sp
Check the process list to make sure it is running.
.INDENT 0.0
.IP \(bu 2
\fB"docker ps"\fP this shows all running process managed by docker
.UNINDENT
.sp
.nf
.ft C
$ docker stop $CONTAINER_ID
.ft P
.fi
.sp
Stop the container, since we don\(aqt need it anymore.
.INDENT 0.0
.IP \(bu 2
\fB"docker stop"\fP This stops a container
.IP \(bu 2
\fB$CONTAINER_ID\fP The Id of the container we want to stop.
.UNINDENT
.sp
.nf
.ft C
docker ps
.ft P
.fi
.sp
Make sure it is really stopped.
.sp
\fBVideo:\fP
.sp
See the example in action
.sp
Continue to the \fIpython_web_app\fP example.
.SS Notes:
.INDENT 0.0
.IP \(bu 2
\fBDocker daemon\fP The docker daemon is started by \fBsudo docker \-d\fP, Vagrant may have started
the Docker daemon for you, but you will need to restart it this way if it was terminated. Otherwise
it may give you \fBCouldn\(aqt create Tag store: open /var/lib/docker/repositories: permission denied\fP
.UNINDENT
.SS Building a python web app
.sp
The goal of this example is to show you how you can author your own docker images using a parent image, making changes to it, and then saving the results as a new image. We will do that by making a simple hello flask web application image.
.sp
\fBSteps:\fP
.sp
.nf
.ft C
$ docker import shykes/pybuilder
.ft P
.fi
.sp
We are importing the "shykes/pybuilder" docker image
.sp
.nf
.ft C
$ URL=http://github.com/shykes/helloflask/archive/master.tar.gz
.ft P
.fi
.sp
We set a URL variable that points to a tarball of a simple helloflask web app
.sp
.nf
.ft C
$ BUILD_JOB=$(docker run \-t shykes/pybuilder:1d9aab3737242c65 /usr/local/bin/buildapp $URL)
.ft P
.fi
.sp
Inside of the "shykes/pybuilder" image there is a command called buildapp, we are running that command and passing the $URL variable from step 2 to it, and running the whole thing inside of a new container. BUILD_JOB will be set with the new container_id. "1d9aab3737242c65" came from the output of step 1 when importing image. also available from \(aqdocker images\(aq.
.sp
.nf
.ft C
$ docker attach $BUILD_JOB
[...]
.ft P
.fi
.sp
We attach to the new container to see what is going on. Ctrl\-C to disconnect
.sp
.nf
.ft C
$ BUILD_IMG=$(docker commit $BUILD_JOB _/builds/github.com/hykes/helloflask/master)
.ft P
.fi
.sp
Save the changed we just made in the container to a new image called "_/builds/github.com/hykes/helloflask/master" and save the image id in the BUILD_IMG variable name.
.sp
.nf
.ft C
$ WEB_WORKER=$(docker run \-p 5000 $BUILD_IMG /usr/local/bin/runapp)
.ft P
.fi
.sp
Use the new image we just created and create a new container with network port 5000, and return the container id and store in the WEB_WORKER variable.
.sp
.nf
.ft C
$ docker logs $WEB_WORKER
 * Running on http://0.0.0.0:5000/
.ft P
.fi
.sp
view the logs for the new container using the WEB_WORKER variable, and if everything worked as planned you should see the line "Running on \fI\%http://0.0.0.0:5000/\fP" in the log output.
.sp
\fBVideo:\fP
.sp
See the example in action
.sp
Continue to the \fI\%base commands\fP
.SH CONTRIBUTING
.SS Contributing to Docker
.sp
Want to hack on Docker? Awesome! There are instructions to get you
started on the website: \fI\%http://docker.io/gettingstarted.html\fP
.sp
They are probably not perfect, please let us know if anything feels
wrong or incomplete.
.SS Contribution guidelines
.SS Pull requests are always welcome
.sp
We are always thrilled to receive pull requests, and do our best to
process them as fast as possible. Not sure if that typo is worth a pull
request? Do it! We will appreciate it.
.sp
If your pull request is not accepted on the first try, don\(aqt be
discouraged! If there\(aqs a problem with the implementation, hopefully you
received feedback on what to improve.
.sp
We\(aqre trying very hard to keep Docker lean and focused. We don\(aqt want it
to do everything for everybody. This means that we might decide against
incorporating a new feature. However, there might be a way to implement
that feature \fIon top of\fP docker.
.SS Discuss your design on the mailing list
.sp
We recommend discussing your plans \fI\%on the mailing
list\fP
before starting to code \- especially for more ambitious contributions.
This gives other contributors a chance to point you in the right
direction, give feedback on your design, and maybe point out if someone
else is working on the same thing.
.SS Create issues...
.sp
Any significant improvement should be documented as \fI\%a github
issue\fP before anybody
starts working on it.
.SS ...but check for existing issues first!
.sp
Please take a moment to check that an issue doesn\(aqt already exist
documenting your bug report or improvement proposal. If it does, it
never hurts to add a quick "+1" or "I have this problem too". This will
help prioritize the most common problems and requests.
.SS Write tests
.sp
Golang has a great testing suite built in: use it! Take a look at
existing tests for inspiration.
.SS Setting up a dev environment
.sp
Instructions that have been verified to work on Ubuntu 12.10,
.sp
Then run the docker daemon,
.sp
Run the \fBgo install\fP command (above) to recompile docker.
.SH COMMANDS
.sp
Contents:
.SS Base commands
.SS Running an interactive shell
.sp
.nf
.ft C
# Download an ubuntu image
docker import ubuntu

# Run an interactive shell in the ubuntu image,
# allocate a tty, attach stdin and stdout
docker run \-a \-i \-t ubuntu /bin/bash
.ft P
.fi
.SS Starting a long\-running worker process
.sp
.nf
.ft C
# Run docker in daemon mode
(docker \-d || echo "Docker daemon already running") &

# Start a very useful long\-running process
JOB=$(docker run ubuntu /bin/sh \-c "while true; do echo Hello world!; sleep 1; done")

# Collect the output of the job so far
docker logs $JOB

# Kill the job
docker kill $JOB
.ft P
.fi
.SS Listing all running containers
.sp
.nf
.ft C
docker ps
.ft P
.fi
.SS Expose a service on a TCP port
.sp
.nf
.ft C
# Expose port 4444 of this container, and tell netcat to listen on it
JOB=$(docker run \-p 4444 ubuntu /bin/nc \-l \-p 4444)

# Which public port is NATed to my container?
PORT=$(docker port $JOB 4444)

# Connect to the public port via the host\(aqs public address
echo hello world | nc $(hostname) $PORT

# Verify that the network connection worked
echo "Daemon received: $(docker logs $JOB)"
.ft P
.fi
.sp
Continue to the complete \fI\%Command Line Interface\fP
.SS Command Line Interface
.SS Docker Usage
.sp
.nf
.ft C
$ docker
  Usage: docker COMMAND [arg...]

  A self\-sufficient runtime for linux containers.

  Commands:
      attach    Attach to a running container
      commit    Create a new image from a container\(aqs changes
      diff      Inspect changes on a container\(aqs filesystem
      export    Stream the contents of a container as a tar archive
      history   Show the history of an image
      images    List images
      import    Create a new filesystem image from the contents of a tarball
      info      Display system\-wide information
      inspect   Return low\-level information on a container
      kill      Kill a running container
      login     Register or Login to the docker registry server
      logs      Fetch the logs of a container
      port      Lookup the public\-facing port which is NAT\-ed to PRIVATE_PORT
      ps        List containers
      pull      Pull an image or a repository to the docker registry server
      push      Push an image or a repository to the docker registry server
      restart   Restart a running container
      rm        Remove a container
      rmi       Remove an image
      run       Run a command in a new container
      start     Start a stopped container
      stop      Stop a running container
      tag       Tag an image into a repository
      version   Show the docker version information
      wait      Block until a container stops, then print its exit code
.ft P
.fi
.SS attach
.sp
.nf
.ft C
Usage: docker attach [OPTIONS]

Attach to a running container

  \-e=true: Attach to stderr
  \-i=false: Attach to stdin
  \-o=true: Attach to stdout
.ft P
.fi
.SS commit
.sp
.nf
.ft C
Usage: docker commit [OPTIONS] CONTAINER [DEST]

Create a new image from a container\(aqs changes

\-m="": Commit message
.ft P
.fi
.SS diff
.sp
.nf
.ft C
Usage: docker diff CONTAINER [OPTIONS]

Inspect changes on a container\(aqs filesystem
.ft P
.fi
.SS export
.sp
.nf
.ft C
Usage: docker export CONTAINER

Export the contents of a filesystem as a tar archive
.ft P
.fi
.SS history
.sp
.nf
.ft C
Usage: docker history [OPTIONS] IMAGE

Show the history of an image
.ft P
.fi
.SS images
.sp
.nf
.ft C
Usage: docker images [OPTIONS] [NAME]

List images

  \-a=false: show all images
  \-q=false: only show numeric IDs
.ft P
.fi
.SS import
.sp
Usage: docker import [OPTIONS] URL|\- [REPOSITORY [TAG]]
.sp
Create a new filesystem image from the contents of a tarball

At this time, the URL must start with ``http`` and point to a single file archive
(.tar, .tar.gz, .tgz, .bzip, .tar.xz, .txz)
containing a root filesystem. If you would like to import from a local directory or archive,
you can use the ``-`` parameter to take the data from standard in.

.SS info
.sp
.nf
.ft C
Usage: docker info

Display system\-wide information.
.ft P
.fi
.SS inspect
.sp
.nf
.ft C
Usage: docker inspect [OPTIONS] CONTAINER

Return low\-level information on a container
.ft P
.fi
.SS kill
.sp
.nf
.ft C
Usage: docker kill [OPTIONS] CONTAINER [CONTAINER...]

Kill a running container
.ft P
.fi
.SS login
.sp
.nf
.ft C
Usage: docker login

Register or Login to the docker registry server
.ft P
.fi
.SS logs
.sp
.nf
.ft C
Usage: docker logs [OPTIONS] CONTAINER

Fetch the logs of a container
.ft P
.fi
.SS port
.sp
.nf
.ft C
Usage: docker port [OPTIONS] CONTAINER PRIVATE_PORT

Lookup the public\-facing port which is NAT\-ed to PRIVATE_PORT
.ft P
.fi
.SS ps
.sp
.nf
.ft C
Usage: docker ps [OPTIONS]

List containers

  \-a=false: Show all containers. Only running containers are shown by default.
  \-notrunc=false: Don\(aqt truncate output
  \-q=false: Only display numeric IDs
.ft P
.fi
.SS pull
.sp
.nf
.ft C
Usage: docker pull NAME

Pull an image or a repository from the registry
.ft P
.fi
.SS push
.sp
.nf
.ft C
Usage: docker push NAME

Push an image or a repository to the registry
.ft P
.fi
.SS restart
.sp
.nf
.ft C
Usage: docker restart [OPTIONS] NAME

Restart a running container
.ft P
.fi
.SS rm
.sp
.nf
.ft C
Usage: docker rm [OPTIONS] CONTAINER

Remove a container
.ft P
.fi
.SS rmi
.sp
.nf
.ft C
Usage: docker rmi [OPTIONS] IMAGE

Remove an image

  \-a=false: Use IMAGE as a path and remove ALL images in this path
  \-r=false: Use IMAGE as a regular expression instead of an exact name
.ft P
.fi
.SS run
.sp
.nf
.ft C
Usage: docker run [OPTIONS] IMAGE COMMAND [ARG...]

Run a command in a new container

  \-a=false: Attach stdin and stdout
  \-c="": Comment
  \-i=false: Keep stdin open even if not attached
  \-m=0: Memory limit (in bytes)
  \-p=[]: Map a network port to the container
  \-t=false: Allocate a pseudo\-tty
  \-u="": Username or UID
.ft P
.fi
.SS start
.sp
.nf
.ft C
Usage: docker start [OPTIONS] NAME

Start a stopped container
.ft P
.fi
.SS stop
.sp
.nf
.ft C
Usage: docker stop [OPTIONS] NAME

Stop a running container
.ft P
.fi
.SS tag
.sp
.nf
.ft C
Usage: docker tag [OPTIONS] IMAGE REPOSITORY [TAG]

Tag an image into a repository

  \-f=false: Force
.ft P
.fi
.SS version
.sp
.nf
.ft C
Usage: docker version

Show the docker version information
.ft P
.fi
.SS wait
.sp
.nf
.ft C
Usage: docker wait [OPTIONS] NAME

Block until a container stops, then print its exit code.
.ft P
.fi
.SH FAQ
.SS Most frequently asked questions.
.sp
\fB1. How much does Docker cost?\fP
.sp
Docker is 100% free, it is open source, so you can use it without paying.
.sp
\fB2. What open source license are you using?\fP
.sp
We are using the Apache License Version 2.0, see it here: \fI\%https://github.com/dotcloud/docker/blob/master/LICENSE\fP
.sp
\fB3. Does Docker run on Mac OS X or Windows?\fP
.sp
Not at this time, Docker currently only runs on Linux, but you can use VirtualBox to run Docker in a virtual machine on your box, and get the best of both worlds. Check out the \fI\%MacOSX\fP and \fI\%Windows\fP intallation guides.
.sp
\fB4. How do containers compare to virtual machines?\fP
.sp
They are complementary. VMs are best used to allocate chunks of hardware resources. Containers operate at the process level, which makes them very lightweight and perfect as a unit of software delivery.
.sp
\fB5. Can I help by adding some questions and answers?\fP
.sp
Definitely! You can fork \fI\%the repo\fP and edit the documentation sources.
.sp
\fB42. Where can I find more answers?\fP
.sp
You can find more answers on:
.INDENT 0.0
.IP \(bu 2
\fI\%IRC: docker on freenode\fP
.IP \(bu 2
\fI\%Github\fP
.IP \(bu 2
\fI\%Ask questions on Stackoverflow\fP
.IP \(bu 2
\fI\%Join the conversation on Twitter\fP
.UNINDENT
.sp
Looking for something else to read? Checkout the \fIhello_world\fP example.
.SH AUTHOR
Team Docker
.SH COPYRIGHT
2013, Team Docker
.\" Generated by docutils manpage writer.
.\" 
.
